.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.22)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SQL::Interp 3"
.TH SQL::Interp 3 "2012-06-27" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
SQL::Interp \- Interpolate Perl variables into SQL statements
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use SQL::Interp \*(Aq:all\*(Aq;
\&
\&  my ($sql, @bind) = sql_interp \*(AqINSERT INTO table\*(Aq, \e%item;
\&  my ($sql, @bind) = sql_interp \*(AqUPDATE table SET\*(Aq,  \e%item, \*(AqWHERE y <> \*(Aq, \e2;
\&  my ($sql, @bind) = sql_interp \*(AqDELETE FROM table WHERE y = \*(Aq, \e2;
\&
\&  # These two select syntax produce the same result
\&  my ($sql, @bind) = sql_interp \*(AqSELECT * FROM table WHERE x = \*(Aq, \e$s, \*(AqAND y IN\*(Aq, \e@v;
\&  my ($sql, @bind) = sql_interp \*(AqSELECT * FROM table WHERE\*(Aq, {x => $s, y => \e@v};
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
SQL::Interp converts a list of intermixed \s-1SQL\s0 fragments and variable references
into a conventional \s-1SQL\s0 string and \fIlist of bind values\fR suitable for passing
onto \s-1DBI\s0. This simple technique creates database calls that are simpler to create and
easier to read, while still giving you full access to custom \s-1SQL\s0.
.PP
SQL::Interp properly binds or escapes variables.  This recommended practice
safeguards against \*(L"\s-1SQL\s0 injection\*(R" attacks. The \s-1DBI\s0 documentation has
several links on the topic.
.PP
Besides the simple techniques shown above, The SQL::Interp integrates directly
with DBIx::Simple for an excellent alternative to raw \s-1DBI\s0 access:
.PP
.Vb 1
\&  use DBIx::Simple;
\&
\&  ...
\&
\&  my $rows = $db\->iquery("
\&      SELECT title
\&          FROM threads
\&          WHERE date > ",\e$x," AND subject IN ",\e@subjects
\&   )\->arrays;
.Ve
.PP
Since DBIx::Simple still allows you complete access to the \s-1DBI\s0 \s-1API\s0, using it as
wrapper is recommended for most applications.
.SH "The One Function You Really Need"
.IX Header "The One Function You Really Need"
.ie n .SS """sql_interp"""
.el .SS "\f(CWsql_interp\fP"
.IX Subsection "sql_interp"
.Vb 1
\&  ($sql, @bind) = sql_interp @params;
.Ve
.PP
\&\f(CW\*(C`sql_interp()\*(C'\fR is the one central function you need to know. \f(CW\*(C`sql_interp()\*(C'\fR
strings together the given list of elements  and returns both an \s-1SQL\s0 string ($sql) with
placeholders (\*(L"?\*(R") and a corresponding list of bind values (@bind) suitable for
passing to \s-1DBI\s0.
.PP
The interpolation list can contain elements of these types:
.PP
* \fB\s-1SQL\s0\fR \- string containing a raw \s-1SQL\s0 fragment such as
\&'\s-1SELECT\s0 * \s-1FROM\s0 mytable \s-1WHERE\s0'.
.PP
* \fBvariable reference\fR \- scalarref, arrayref, hashref, or
A \fIsql_type()\fR object referring to data to interpolate between
the \s-1SQL\s0.
.PP
* \fBother interpolation list\fR \- an interpolation list can be nested
inside another interpolation list.  This is possible with the \fIsql()\fR
function.
.PP
\&\fBInterpolation Examples\fR
.PP
The following variable names will be used in the below examples:
.PP
.Vb 6
\& $sref  = \e3;                      # scalarref
\& $aref  = [1, 2];                  # arrayref
\& $href  = {m => 1, n => undef};    # hashref
\& $hv = {v => $v, s => $$s};        # hashref containing arrayref
\& $vv = [$v, $v];                   # arrayref of arrayref
\& $vh = [$h, $h];                   # arrayref of hashref
\&
\& Let $x stand for any of these.
.Ve
.PP
\fIDefault scalarref behavior\fR
.IX Subsection "Default scalarref behavior"
.PP
A scalarref becomes a single bind value.
.PP
.Vb 2
\&  IN:  \*(Aqfoo\*(Aq, $sref, \*(Aqbar\*(Aq
\&  OUT: \*(Aqfoo ? bar\*(Aq, $$sref
.Ve
.PP
\fIDefault hashref behavior\fR
.IX Subsection "Default hashref behavior"
.PP
A hashref becomes a logical \s-1AND\s0
.PP
.Vb 2
\&  IN:  \*(AqWHERE\*(Aq, $href
\&  OUT: \*(AqWHERE (m=? AND n IS NULL)\*(Aq, $h\->{m},
\&
\&  IN:  \*(AqWHERE\*(Aq, $hv
\&  OUT: \*(AqWHERE (v IN (?, ?) AND s = ?)\*(Aq, @$v, $$s
.Ve
.PP
\fIDefault arrayref of (hashref or arrayref) behavior\fR
.IX Subsection "Default arrayref of (hashref or arrayref) behavior"
.PP
\&\fIThis is not commonly used.\fR
.PP
.Vb 3
\&  IN:  $vv
\&  OUT: \*(Aq(SELECT ?, ? UNION ALL SELECT ?, ?)\*(Aq,
\&          map {@$_} @$v
\&
\&  IN:  $vh
\&  OUT: \*(Aq(SELECT ? as m, ? as n UNION ALL
\&            SELECT ?, ?)\*(Aq,
\&          $vh\->[0]\->{m}, $vh\->[0]\->{n},
\&          $vh\->[1]\->{m}, $vh\->[1]\->{n}
\&
\&  # Typical usage:
\&  IN: $x
\&  IN: $x, \*(AqUNION [ALL|DISTINCT]\*(Aq, $x
\&  IN: \*(AqINSERT INTO mytable\*(Aq, $x
\&  IN: \*(AqSELECT * FROM mytable WHERE x IN\*(Aq, $x
.Ve
.PP
\fIContext ('\s-1IN\s0', \f(CI$x\fI)\fR
.IX Subsection "Context ('IN', $x)"
.PP
A scalarref or arrayref can used to form an \*(L"\s-1IN\s0\*(R" clause.  As a convenience,
a reference to an arrayref is also accepted.  This way, you can simply provide
a reference to a value which may be a single-valued scalar or a multi-valued
arrayref.
.PP
.Vb 2
\&  IN:  \*(AqWHERE x IN\*(Aq, $aref
\&  OUT: \*(AqWHERE x IN (?, ?)\*(Aq, @$aref
\&
\&  IN:  \*(AqWHERE x IN\*(Aq, $sref
\&  OUT: \*(AqWHERE x IN (?)\*(Aq, $$sref
\&
\&  IN:  \*(AqWHERE x IN\*(Aq, []
\&  OUT: \*(AqWHERE 1=0\*(Aq
\&
\&  IN:  \*(AqWHERE x NOT IN\*(Aq, []
\&  OUT: \*(AqWHERE 1=1\*(Aq
.Ve
.PP
\fIContext ('\s-1INSERT\s0 \s-1INTO\s0 tablename', \f(CI$x\fI)\fR
.IX Subsection "Context ('INSERT INTO tablename', $x)"
.PP
.Vb 2
\&  IN:  \*(AqINSERT INTO mytable\*(Aq, $href
\&  OUT: \*(AqINSERT INTO mytable (m, n) VALUES(?, ?)\*(Aq, $href\->{m}, $href\->{n}
\&
\&  IN:  \*(AqINSERT INTO mytable\*(Aq, $aref
\&  OUT: \*(AqINSERT INTO mytable VALUES(?, ?)\*(Aq, @$aref;
\&
\&  IN:  \*(AqINSERT INTO mytable\*(Aq, $sref
\&  OUT: \*(AqINSERT INTO mytable VALUES(?)\*(Aq, $$sref;
.Ve
.PP
MySQL's \*(L"\s-1REPLACE\s0 \s-1INTO\s0\*(R" is supported the same way.
.PP
\fIContext ('\s-1SET\s0', \f(CI$x\fI)\fR
.IX Subsection "Context ('SET', $x)"
.PP
.Vb 2
\&  IN:  \*(AqUPDATE mytable SET\*(Aq, $href
\&  OUT: \*(AqUPDATE mytable SET m = ?, n = ?\*(Aq, $href\->{m}, $href\->{n}
.Ve
.PP
MySQL's \*(L"\s-1ON\s0 \s-1DUPLICATE\s0 \s-1KEY\s0 \s-1UPDATE\s0\*(R" is supported the same way.
.PP
\fIContext ('\s-1FROM\s0 | \s-1JOIN\s0', \f(CI$x\fI)\fR
.IX Subsection "Context ('FROM | JOIN', $x)"
.PP
\&\fIThis is not commonly used.\fR
.PP
.Vb 4
\&  IN:  \*(AqSELECT * FROM\*(Aq, $vv
\&  OUT: \*(AqSELECT * FROM
\&       (SELECT ?, ? UNION ALL SELECT ?, ?) as t001\*(Aq,
\&       map {@$_} @$v
\&
\&  IN:  \*(AqSELECT * FROM\*(Aq, $vh
\&  OUT: \*(AqSELECT * FROM
\&       (SELECT ? as m, ? as n UNION ALL SELECT ?, ?) as temp001\*(Aq,
\&       $vh\->[0]\->{m}, $vh\->[0]\->{n},
\&       $vh\->[1]\->{m}, $vh\->[1]\->{n}
\&
\&  IN:  \*(AqSELECT * FROM\*(Aq, $vv, \*(AqAS t\*(Aq
\&  OUT: \*(AqSELECT * FROM
\&       (SELECT ?, ? UNION ALL SELECT ?, ?) AS t\*(Aq,
\&       map {@$_} @$v
\&
\&  # Example usage (where $x and $y are table references):
\&  \*(AqSELECT * FROM\*(Aq, $x, \*(AqJOIN\*(Aq, $y
.Ve
.PP
\fIOther Rules\fR
.IX Subsection "Other Rules"
.PP
Whitespace is automatically added between parameters:
.PP
.Vb 2
\& IN:  \*(AqUPDATE\*(Aq, \*(Aqmytable SET\*(Aq, {x => 2}, \*(AqWHERE y IN\*(Aq, \e@colors;
\& OUT: \*(AqUPDATE mytable SET x = ? WHERE y in (?, ?)\*(Aq, 2, @colors
.Ve
.PP
Variables must be passed as references; otherwise, they will
processed as \s-1SQL\s0 fragments and interpolated verbatim into the
result \s-1SQL\s0 string, negating the security and performance benefits
of binding values.
.PP
In contrast, any scalar values \fIinside\fR an arrayref or hashref are by
default treated as binding variables, not \s-1SQL\s0.  The contained
elements may be also be \fIsql_type()\fR or \fIsql()\fR.
.SH "Security: sql_interp_strict"
.IX Header "Security: sql_interp_strict"
The \f(CW\*(C`sql_interp\*(C'\fR function has a security weakness. Consider these two
statements, one easily a typo of the other:
.PP
.Vb 2
\&    sql_interp("SELECT * FROM foo WHERE a = ",\e$b)
\&    sql_interp("SELECT * FROM foo WHERE a = ",$b)
.Ve
.PP
Both would produce valid \s-1SQL\s0, but the first would be secure due to use of bind
variables, while the second is potentially insecure, because \f(CW$b\fR is added
directly to the \s-1SQL\s0 statement. If \f(CW$b\fR contains a malicious value, it
could be used for a \s-1SQL\s0 injection attack.
.PP
To prevent this accident, we also supply \f(CW\*(C`sql_interp_strict()\*(C'\fR, which
works exactly the same as \fIsql_interp()\fR, but with an additional check that \fB
two non-references never appear in a row \fR. If they do, an exception will be
thrown.
.PP
This does mean some previously safe-but-valid \s-1SQL\s0 be need to be rewritten, such
as when you are building a complex query from pieces. Here's a contrived example:
.PP
.Vb 1
\&    sql_interp("SELECT * FROM ","foo","WHERE a = ",\e$b);
.Ve
.PP
To work under strict mode, you need to concatenate the strings instead:
.PP
.Vb 1
\&    sql_interp("SELECT * FROM "."foo"."WHERE a = ",\e$b);
.Ve
.SH "A Couple Helper Functions You Sometimes Need"
.IX Header "A Couple Helper Functions You Sometimes Need"
.ie n .SS """sql()"""
.el .SS "\f(CWsql()\fP"
.IX Subsection "sql()"
.Vb 3
\&  sql_interp \*(AqINSERT INTO mytable\*(Aq,
\&      {x => $x, y => sql(\*(AqCURRENT_TIMESTAMP\*(Aq)};
\&  # OUT: \*(AqINSERT INTO mytable (x, y) VALUES(?, CURRENT_TIMESTAMP)\*(Aq, $x
.Ve
.PP
\&\fIsql()\fR is useful if you want insert raw \s-1SQL\s0 as a value in an arrayref or hashref.
.ie n .SS """sql_type()"""
.el .SS "\f(CWsql_type()\fP"
.IX Subsection "sql_type()"
.Vb 1
\&  my $sqlvar = sql_type($value_ref, type => $sql_type, %params);
.Ve
.PP
\&\f(CW\*(C`sql_type()\*(C'\fR provides a general way to represent a binding variable \fIalong
with\fR metadata.  It is necessary in rare applications which you need to
explicity give the bind type of a \s-1SQL\s0 variable.
.PP
\&\f(CW$value_ref\fR \- variable reference contained
.PP
\&\f(CW$sql_type\fR \- any \s-1DBI\s0 \s-1SQL_DATA_TYPE\s0 (e.g. \s-1SQL_INTEGER\s0).  Optional.
Default is undef.
.PP
Any other named parameters (%params) passed in will be saved into the
object as attributes.
.PP
sql_type objects are useful only in special cases where additional
information should be tagged onto the variable.  For example, \s-1DBI\s0
allows bind variables to be given an explicit type:
.PP
.Vb 7
\&  my ($sql, @bind) = sql_interp \*(AqSELECT * FROM mytable WHERE\*(Aq,
\&      \*(Aqx=\*(Aq, \e$x, \*(AqAND y=\*(Aq, sql_type(\e$y, SQL_VARCHAR), \*(AqAND z IN\*(Aq,
\&      sql_type([1, 2], SQL_INTEGER);
\&  # RESULT: @bind =
\&  #   ([$x, sql_type(\e$x)], [$y, sql_type(\e$y, type => SQL_VARCHAR)],
\&  #    [1, sql_type([1, 2], type => SQL_INTEGER)],
\&  #    [2, sql_type([1, 2], type => SQL_INTEGER)]);
\&
\&  my $idx = 1;
\&  for my $var (@bind) {
\&      $sth\->bind_param($idx++, $var\->[0], $var\->[1]\->{type});
\&  }
\&  $sth\->execute();
\&  my $ret = $sth\->selectall_arrayref();
.Ve
.PP
If the interpolation list contains at least one sql_type object, then
all the variable references are transparently converted into sql_type
objects, and the elements of \f(CW@bind\fR take a special form: an arrayref
consisting of the bind value and the sql_type object that generated the
bind value.  Note that a single sql_type holding an aggregate (arrayref
or hashref) may generate multiple bind values.
.SH "Enabling debugging output"
.IX Header "Enabling debugging output"
To have the generated \s-1SQL\s0 and bind variables sent to \s-1STDOUT\s0,
you can set the environment variable \f(CW\*(C`TRACE_SQL\*(C'\fR to \*(L"1\*(R"
.PP
.Vb 1
\& TRACE_SQL=1 perl my_script.pl
.Ve
.PP
Here's some example output:
.PP
.Vb 1
\& DEBUG:interp[sql=INSERT INTO mytable VALUES(?),bind=5]
.Ve
.SH "Philosophy"
.IX Header "Philosophy"
\&\fBThe query language is \s-1SQL\s0\fR.  There are other modules, such as
SQL::Abstract, that hide \s-1SQL\s0 behind method calls and/or Perl
data structures (hashes and arrays).  The former may be undesirable in some
cases since it replaces one language with another and hides the full
capabilities and expressiveness of your database's native \s-1SQL\s0 language.  The
latter may load too much meaning into the syntax of \*(L"{, \*(R"[\*(L" and \*(R"\e" thereby
rendering the meaning less clear:
.PP
.Vb 5
\&  SQL::Abstract example:
\&  %where = (lname => {like => \*(Aq%son%\*(Aq},
\&            age   => [\-and => {\*(Aq>=\*(Aq, 10}, {\*(Aq<=\*(Aq, 20}])
\&  Plain SQL:
\&  "lname LIKE \*(Aq%son\*(Aq AND (age >= 10 AND age <= 20)"
.Ve
.PP
In contrast, SQL::Interp does not abstract away your \s-1SQL\s0 but rather makes it
easier to interpolate Perl variables into your \s-1SQL\s0.  Now, SQL::Interp \fIdoes\fR
load some meaning into \*(L"{, \*(R"[\*(L" and \*(R"\e", but we try to limit its use to obvious
cases.  Since your raw \s-1SQL\s0 is exposed, you can use your particular dialect of
\&\s-1SQL\s0.
.SH "Limitations"
.IX Header "Limitations"
Some types of interpolation are context-sensitive and involve examination of
your \s-1SQL\s0 fragments.  The examination could fail on obscure syntax, but it is
generally robust.  Look at the examples to see the types of interpolation that
are accepted, and if doubt, examine the \s-1SQL\s0 output yourself with the \s-1TRACE_SQL\s0
environment variable set.  If needed, you can disable context sensitivity by inserting a
null-string before a variable.
.PP
.Vb 1
\& "SET", "", \e$x
.Ve
.PP
A few things are just not possible with the ('\s-1WHERE\s0', \e%hashref)
syntax, so in such case, use a more direct syntax:
.PP
.Vb 5
\&  # ok\-\-direct syntax
\&  sql_interp \*(Aq...WHERE\*(Aq, {x => $x, y => $y}, \*(AqAND y = z\*(Aq;
\&  # bad\-\-trying to impose a hashref but keys must be scalars and be unique
\&  sql_interp \*(Aq...WHERE\*(Aq,
\&      {sql_type(\e$x) => sql(\*(Aqx\*(Aq), y => $y, y => sql(\*(Aqz\*(Aq)};
.Ve
.PP
In the cases where this module parses or generates \s-1SQL\s0 fragments, this module
should work for many databases, but its been tested mostly on MySQL and
PostgreSQL.  Please inform the author of any incompatibilities.
.SH "Contributor and Contributing"
.IX Header "Contributor and Contributing"
David Manura (<http://math2.org/david/contact>) (author).
Mark Stosberg (<http://mark.stosberg.com/>) created and maintains
the SQL::Interp fork. Also thanks to: Mark Tiefenbruck (syntax), Wojciech Pietron (Oracle
compat), Jim Chromie (DBIx::Interp idea), Juerd Waalboer,
Terrence Brannon (early feedback), and others.
.PP
If you like SQL::Interp, please consider supporting the project by adding
support for the 'quote_char' and 'name_sep' options. SQL::Abstract has code
that can be borrowed for this. See this bug report for details:
http://rt.cpan.org/Public/Bug/Display.html?id=31488
.PP
If you use SQL::Interp with PostgreSQL and are interested in a further
performance improvement, considering working on this optimization: \*(L"RT#39778:
wish: optimize \s-1\fIIN\s0()\fR to be \s-1\fIANY\s0()\fR for compatible PostgreSQL versions\*(R":
https://rt.cpan.org/Ticket/Display.html?id=39778
.PP
SQL::Interp now has a code repository hosted on Github:
.PP
.Vb 1
\& L<https://github.com/markstos/SQL\-Interp>
.Ve
.SH "Bug Reporting"
.IX Header "Bug Reporting"
Use rt.cpan.org for bug reports.
.SH "License"
.IX Header "License"
Copyright (c) 2003\-2005, David Manura.
This module is free software. It may be used, redistributed
and/or modified under the same terms as Perl itself.
See <http://www.perl.com/perl/misc/Artistic.html>.
.SH "See Also"
.IX Header "See Also"
.SS "Fork"
.IX Subsection "Fork"
This module was forked from SQL::Interpolate, around version 0.40.  The core
functionality remains unchanged, but the following  incompatible changes have
been made:
.IP "\(bu" 4
The optional source filtering feature was removed.
.IP "\(bu" 4
The optional \*(L"macro\*(R" feature was removed.
.IP "\(bu" 4
A legacy, deprecated function \*(L"sql_literal\*(R" was removed.
.IP "\(bu" 4
The docs were overhauled to be simpler and clearer.
.PP
So if you want those removed features, you should use SQL::Interpolate. I
used it for years without those optional features and never missed them.
.SS "Other modules in this distribution"
.IX Subsection "Other modules in this distribution"
DBIx::Interp allows \s-1DBI\s0 methods to accept an
\&\f(CW\*(C`sql_interp()\*(C'\fR\-like interpolation list rather than the traditional
($statement, \e%attr, \f(CW@bind_values\fR) parameter list. However, consider
using DBIx::Simple instead\*(-- it even more user friendly.
.SS "Related modules"
.IX Subsection "Related modules"
\fISQL::Abstract\fR
.IX Subsection "SQL::Abstract"
.PP
SQL::Abstract shares with \f(CW\*(C`SQL::Interp\*(C'\fR the
purpose of making \s-1SQL\s0 generation easier. SQL::Abstract differs in that
it expresses queries in terms of \s-1OO\s0 method calls. It's syntax may
impair readability because it uses the subtle difference between a
brace and bracket to denote the difference between \s-1AND\s0 and \s-1OR\s0 in a
query (the user can change whether a bracket implies \*(L"\s-1AND\s0\*(R" or
\&\*(L"\s-1OR\s0\*(R"). Some complex where clauses are difficult or impossible with
SQL::Abstract.  SQL::Interp gives the author
more direct access to the underlying \s-1SQL\s0.  This permits using the full
expressivity of the database query language.
.PP
\fIDBIx::Simple\fR
.IX Subsection "DBIx::Simple"
.PP
DBIx::Simple strives to simplify \s-1SQL\s0 generation as
well as the data structures returned from
\&\s-1DBI\s0. \f(CW\*(C`DBIx::Simple\*(C'\fR currently can use
SQL::Interp to help generate \s-1SQL\s0.
.PP
\fIClass::DBI\fR
.IX Subsection "Class::DBI"
.PP
Class::DBI is a popular \*(L"complete\*(R" solution for abstract
database access through an \s-1OO\s0 interface. It currently has a plugin
called Class::DBI::AbstractSearch that
allows it to use \f(CW\*(C`SQL::Abstract\*(C'\fR to generate \s-1SQL\s0. It's possible that
\&\f(CW\*(C`SQL::Interp\*(C'\fR could be integrated with it as well.
.PP
\fISQL::Preproc\fR
.IX Subsection "SQL::Preproc"
.PP
SQL::Preproc provides an \*(L"embedded \s-1SQL\s0\*(R" approach where
the Perl and \s-1SQL\s0 languages are extended (via source filtering) to
support interwoven Perl and \s-1SQL\s0.  The syntax supports interpolating
Perl variables into \s-1SQL\s0 and passing query results back into Perl variables.  In
contrast, SQL::Interp extends neither \s-1SQL\s0 nor Perl, and it deals only with
interpolating Perl variables into queries, whereas returning variables from
queries is the job of something like \s-1DBI\s0, DBIx::Interp, or DBIx::Simple.
.PP
\fISQL::String\fR
.IX Subsection "SQL::String"
.PP
SQL::String shares a number of similiarities to
SQL::Interp but it is more rudimentary.  Both let you combine
\&\*(L"chunks\*(R" of \s-1SQL\s0 that have their parameters attached to them and then
transform it into an \s-1SQL\s0 string and list of bind parameters suitable
for passing to \s-1DBI\s0.
.PP
\fISQL::KeywordSearch\fR
.IX Subsection "SQL::KeywordSearch"
.PP
SQL::KeywordSearch helps generate \s-1SQL\s0 for a keyword search.
It can return the result in a format compatible with SQL::Interp to become part
of a larger query.
