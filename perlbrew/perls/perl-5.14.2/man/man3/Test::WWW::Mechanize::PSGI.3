.\" Automatically generated by Pod::Man 2.26 (Pod::Simple 3.22)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::WWW::Mechanize::PSGI 3"
.TH Test::WWW::Mechanize::PSGI 3 "2010-01-06" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Test::WWW::Mechanize::PSGI \- Test PSGI programs using WWW::Mechanize
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # We\*(Aqre in a t/*.t test script...
\&  use Test::WWW::Mechanize::PSGI;
\&
\&  my $mech = Test::WWW::Mechanize::PSGI\->new(
\&      app => sub {
\&          my $env = shift;
\&          return [
\&              200,
\&              [ \*(AqContent\-Type\*(Aq => \*(Aqtext/html\*(Aq ],
\&              [ \*(Aq<html><head><title>Hi</title></head><body>Hello World</body></html>\*(Aq
\&              ]
\&          ];
\&      },
\&  );
\&  $mech\->get_ok(\*(Aq/\*(Aq);
\&  is( $mech\->ct, \*(Aqtext/html\*(Aq, \*(AqIs text/html\*(Aq );
\&  $mech\->title_is(\*(AqHi\*(Aq);
\&  $mech\->content_contains(\*(AqHello World\*(Aq);
\&  # ... and all other Test::WWW::Mechanize methods
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1PSGI\s0 is a specification to decouple web server environments from
web application framework code. Test::WWW::Mechanize is a subclass
of WWW::Mechanize that incorporates features for web application
testing. The Test::WWW::Mechanize::PSGI module meshes the two to
allow easy testing of \s-1PSGI\s0 applications.
.PP
Testing web applications has always been a bit tricky, normally
requiring starting a web server for your application and making real \s-1HTTP\s0
requests to it. This module allows you to test \s-1PSGI\s0 web
applications but does not require a server or issue \s-1HTTP\s0
requests. Instead, it passes the \s-1HTTP\s0 request object directly to
\&\s-1PSGI\s0. Thus you do not need to use a real hostname:
\&\*(L"http://localhost/\*(R" will do. However, this is optional. The following
two lines of code do exactly the same thing:
.PP
.Vb 2
\&  $mech\->get_ok(\*(Aq/action\*(Aq);
\&  $mech\->get_ok(\*(Aqhttp://localhost/action\*(Aq);
.Ve
.PP
This makes testing fast and easy. Test::WWW::Mechanize provides
functions for common web testing scenarios. For example:
.PP
.Vb 4
\&  $mech\->get_ok( $page );
\&  $mech\->title_is( "Invoice Status", "Make sure we\*(Aqre on the invoice page" );
\&  $mech\->content_contains( "Andy Lester", "My name somewhere" );
\&  $mech\->content_like( qr/(cpan|perl)\e.org/, "Link to perl.org or CPAN" );
.Ve
.PP
An alternative to this module is Plack::Test.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
Behaves like, and calls, WWW::Mechanize's \f(CW\*(C`new\*(C'\fR method. You should pass
in your application:
.PP
.Vb 6
\&  my $mech = Test::WWW::Mechanize::PSGI\->new(
\&      app => sub {
\&          my $env = shift;
\&          return [ 200, [ \*(AqContent\-Type\*(Aq => \*(Aqtext/plain\*(Aq ], [\*(AqHello World\*(Aq] ],;
\&      },
\&  );
.Ve
.SH "METHODS: HTTP VERBS"
.IX Header "METHODS: HTTP VERBS"
.ie n .SS "$mech\->get_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->get_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->get_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fIget()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1GET\s0 \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->head_ok($url, [ \e%LWP_options ,] $desc)"
.el .SS "\f(CW$mech\fP\->head_ok($url, [ \e%LWP_options ,] \f(CW$desc\fP)"
.IX Subsection "$mech->head_ok($url, [ %LWP_options ,] $desc)"
A wrapper around WWW::Mechanize's \fIhead()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1HEAD\s0 \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->post_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->post_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->post_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fIpost()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1POST\s0 to \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->put_ok( $url, [ \e%LWP_options ,] $desc )"
.el .SS "\f(CW$mech\fP\->put_ok( \f(CW$url\fP, [ \e%LWP_options ,] \f(CW$desc\fP )"
.IX Subsection "$mech->put_ok( $url, [ %LWP_options ,] $desc )"
A wrapper around WWW::Mechanize's \fIput()\fR, with similar options, except
the second argument needs to be a hash reference, not a hash. Like
well-behaved \f(CW\*(C`*_ok()\*(C'\fR functions, it returns true if the test passed,
or false if not.
.PP
A default description of \*(L"\s-1PUT\s0 to \f(CW$url\fR\*(R" is used if none if provided.
.ie n .SS "$mech\->submit_form_ok( \e%parms [, $desc] )"
.el .SS "\f(CW$mech\fP\->submit_form_ok( \e%parms [, \f(CW$desc\fP] )"
.IX Subsection "$mech->submit_form_ok( %parms [, $desc] )"
Makes a \f(CW\*(C`submit_form()\*(C'\fR call and executes tests on the results.
The form must be found, and then submitted successfully.  Otherwise,
this test fails.
.PP
\&\fI\f(CI%parms\fI\fR is a hashref containing the parms to pass to \f(CW\*(C`submit_form()\*(C'\fR.
Note that the parms to \f(CW\*(C`submit_form()\*(C'\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 1
\&    $agent\->submit_form_ok( {n=>3}, "looking for 3rd link" );
.Ve
.PP
As with other test functions, \f(CW$desc\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fIsubmit_form()\fR
is not available.
.ie n .SS "$mech\->follow_link_ok( \e%parms [, $desc] )"
.el .SS "\f(CW$mech\fP\->follow_link_ok( \e%parms [, \f(CW$desc\fP] )"
.IX Subsection "$mech->follow_link_ok( %parms [, $desc] )"
Makes a \f(CW\*(C`follow_link()\*(C'\fR call and executes tests on the results.
The link must be found, and then followed successfully.  Otherwise,
this test fails.
.PP
\&\fI\f(CI%parms\fI\fR is a hashref containing the parms to pass to \f(CW\*(C`follow_link()\*(C'\fR.
Note that the parms to \f(CW\*(C`follow_link()\*(C'\fR are a hash whereas the parms to
this function are a hashref.  You have to call this function like:
.PP
.Vb 1
\&    $mech\->follow_link_ok( {n=>3}, "looking for 3rd link" );
.Ve
.PP
As with other test functions, \f(CW$desc\fR is optional.  If it is supplied
then it will display when running the test harness in verbose mode.
.PP
Returns a true value if the specified link was found and followed
successfully.  The HTTP::Response object returned by \fIfollow_link()\fR
is not available.
.ie n .SS "click_ok( $button[, $desc] )"
.el .SS "click_ok( \f(CW$button\fP[, \f(CW$desc\fP] )"
.IX Subsection "click_ok( $button[, $desc] )"
Clicks the button named by \f(CW$button\fR.  An optional \f(CW$desc\fR can
be given for the test.
.SH "METHODS: CONTENT CHECKING"
.IX Header "METHODS: CONTENT CHECKING"
.ie n .SS "$mech\->html_lint_ok( [$desc] )"
.el .SS "\f(CW$mech\fP\->html_lint_ok( [$desc] )"
.IX Subsection "$mech->html_lint_ok( [$desc] )"
Checks the validity of the \s-1HTML\s0 on the current page.  If the page is not
\&\s-1HTML\s0, then it fails.  The \s-1URI\s0 is automatically appended to the \fI\f(CI$desc\fI\fR.
.PP
Note that HTML::Lint must be installed for this to work.  Otherwise,
it will blow up.
.ie n .SS "$mech\->title_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_is( $str [, $desc ] )"
Tells if the title of the page is the given string.
.PP
.Vb 1
\&    $mech\->title_is( "Invoice Summary" );
.Ve
.ie n .SS "$mech\->title_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_like( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_like( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->title_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->title_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->title_unlike( $regex [, $desc ] )"
Tells if the title of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->title_unlike( qr/Invoices for (.+)/
.Ve
.ie n .SS "$mech\->base_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_is( $str [, $desc ] )"
Tells if the base of the page is the given string.
.PP
.Vb 1
\&    $mech\->base_is( "http://example.com/" );
.Ve
.ie n .SS "$mech\->base_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_like( $regex [, $desc ] )"
Tells if the base of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->base_like( qr{http://example.com/index.php?PHPSESSID=(.+)});
.Ve
.ie n .SS "$mech\->base_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->base_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->base_unlike( $regex [, $desc ] )"
Tells if the base of the page matches the given regex.
.PP
.Vb 1
\&    $mech\->base_unlike( qr{http://example.com/index.php?PHPSESSID=(.+)});
.Ve
.ie n .SS "$mech\->content_is( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_is( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_is( $str [, $desc ] )"
Tells if the content of the page matches the given string
.ie n .SS "$mech\->content_contains( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_contains( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_contains( $str [, $desc ] )"
Tells if the content of the page contains \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->content_lacks( $str [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_lacks( \f(CW$str\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_lacks( $str [, $desc ] )"
Tells if the content of the page lacks \fI\f(CI$str\fI\fR.
.ie n .SS "$mech\->content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_like( $regex [, $desc ] )"
Tells if the content of the page matches \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->content_unlike( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->content_unlike( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->content_unlike( $regex [, $desc ] )"
Tells if the content of the page does \s-1NOT\s0 match \fI\f(CI$regex\fI\fR.
.ie n .SS "$mech\->has_tag( $tag, $text [, $desc ] )"
.el .SS "\f(CW$mech\fP\->has_tag( \f(CW$tag\fP, \f(CW$text\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->has_tag( $tag, $text [, $desc ] )"
Tells if the page has a \f(CW$tag\fR tag with the given content in its text.
.ie n .SS "$mech\->has_tag_like( $tag, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->has_tag_like( \f(CW$tag\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->has_tag_like( $tag, $regex [, $desc ] )"
Tells if the page has a \f(CW$tag\fR tag with the given content in its text.
.ie n .SS "$mech\->\fIfollowable_links()\fP"
.el .SS "\f(CW$mech\fP\->\fIfollowable_links()\fP"
.IX Subsection "$mech->followable_links()"
Returns a list of links that Mech can follow.  This is only http and
https links.
.ie n .SS "$mech\->page_links_ok( [ $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_ok( [ \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_ok( [ $desc ] )"
Follow all links on the current page and test for \s-1HTTP\s0 status 200
.PP
.Vb 1
\&    $mech\->page_links_ok(\*(AqCheck all links\*(Aq);
.Ve
.ie n .SS "$mech\->page_links_content_like( $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->page_links_content_like( \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->page_links_content_like( $regex [, $desc ] )"
Follow all links on the current page and test their contents for \fI\f(CI$regex\fI\fR.
.PP
.Vb 2
\&    $mech\->page_links_content_like( qr/foo/,
\&      \*(AqCheck all links contain "foo"\*(Aq );
.Ve
.ie n .SS "$mech\->links_ok( $links [, $desc ] )"
.el .SS "\f(CW$mech\fP\->links_ok( \f(CW$links\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->links_ok( $links [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
200.  The links may be specified as a reference to an array containing
WWW::Mechanize::Link objects, an array of URLs, or a scalar \s-1URL\s0
name.
.PP
.Vb 2
\&    my @links = $mech\->find_all_links( url_regex => qr/cnn\e.com$/ );
\&    $mech\->links_ok( \e@links, \*(AqCheck all links for cnn.com\*(Aq );
\&
\&    my @links = qw( index.html search.html about.html );
\&    $mech\->links_ok( \e@links, \*(AqCheck main links\*(Aq );
\&
\&    $mech\->links_ok( \*(Aqindex.html\*(Aq, \*(AqCheck link to index\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_is( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_is( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_is( $links, $status [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_status_is( \e@links, 403,
\&      \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_status_isnt( $links, $status [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_status_isnt( \f(CW$links\fP, \f(CW$status\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_status_isnt( $links, $status [, $desc ] )"
Follow specified links on the current page and test for \s-1HTTP\s0 status
passed.  The links may be specified as a reference to an array
containing WWW::Mechanize::Link objects, an array of URLs, or a
scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_status_isnt( \e@links, 404,
\&      \*(AqCheck all links are not 404\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_like( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_like( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_like( $links, $regex [, $desc ] )"
Follow specified links on the current page and test the resulting
content of each against \fI\f(CI$regex\fI\fR.  The links may be specified as a
reference to an array containing WWW::Mechanize::Link objects, an
array of URLs, or a scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_content_like( \e@links, qr/Restricted/,
\&        \*(AqCheck all links are restricted\*(Aq );
.Ve
.ie n .SS "$mech\->link_content_unlike( $links, $regex [, $desc ] )"
.el .SS "\f(CW$mech\fP\->link_content_unlike( \f(CW$links\fP, \f(CW$regex\fP [, \f(CW$desc\fP ] )"
.IX Subsection "$mech->link_content_unlike( $links, $regex [, $desc ] )"
Follow specified links on the current page and test that the resulting
content of each does not match \fI\f(CI$regex\fI\fR.  The links may be specified as a
reference to an array containing WWW::Mechanize::Link objects, an array
of URLs, or a scalar \s-1URL\s0 name.
.PP
.Vb 3
\&    my @links = $mech\->followable_links();
\&    $mech\->link_content_unlike( \e@links, qr/Restricted/,
\&      \*(AqNo restricted links\*(Aq );
.Ve
.ie n .SS "$mech\->stuff_inputs( [\e%options] )"
.el .SS "\f(CW$mech\fP\->stuff_inputs( [\e%options] )"
.IX Subsection "$mech->stuff_inputs( [%options] )"
Finds all free-text input fields (text, textarea, and password) in the
current form and fills them to their maximum length in hopes of finding
application code that can't handle it.  Fields with no maximum length
and all textarea fields are set to 66000 bytes, which will often be
enough to overflow the data's eventual recepticle.
.PP
There is no return value.
.PP
If there is no current form then nothing is done.
.PP
The hashref \f(CW$options\fR can contain the following keys:
.IP "\(bu" 4
ignore
.Sp
hash value is arrayref of field names to not touch, e.g.:
.Sp
.Vb 3
\&    $mech\->stuff_inputs( {
\&        ignore => [qw( specialfield1 specialfield2 )],
\&    } );
.Ve
.IP "\(bu" 4
fill
.Sp
hash value is default string to use when stuffing fields.  Copies
of the string are repeated up to the max length of each field.  E.g.:
.Sp
.Vb 3
\&    $mech\->stuff_inputs( {
\&        fill => \*(Aq@\*(Aq  # stuff all fields with something easy to recognize
\&    } );
.Ve
.IP "\(bu" 4
specs
.Sp
hash value is arrayref of hashrefs with which you can pass detailed
instructions about how to stuff a given field.  E.g.:
.Sp
.Vb 8
\&    $mech\->stuff_inputs( {
\&        specs=>{
\&            # Some fields are datatype\-constrained.  It\*(Aqs most common to
\&            # want the field stuffed with valid data.
\&            widget_quantity => { fill=>\*(Aq9\*(Aq },
\&            notes => { maxlength=>2000 },
\&        }
\&    } );
.Ve
.Sp
The specs allowed are \fIfill\fR (use this fill for the field rather than
the default) and \fImaxlength\fR (use this as the field's maxlength instead
of any maxlength specified in the \s-1HTML\s0).
.SH "AUTHOR"
.IX Header "AUTHOR"
Leon Brocard <acme@astray.com>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2009, Leon Brocard
.SH "LICENSE"
.IX Header "LICENSE"
This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.
